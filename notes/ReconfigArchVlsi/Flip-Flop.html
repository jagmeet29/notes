<script src="../comm.js"></script>
<link rel="stylesheet" href="../css.css" />
<div id="container">
  <h1>$1$-Bit Storage Element</h1>
  <h2>SR LAtch</h2>
  <blockquote>
    The SR latch (Set-Reset latch) is a fundamental digital storage element that
    serves as the building block for more complex sequential circuits. It
    consists of two cross-coupled logic gates that create a feedback loop,
    allowing the circuit to store one bit of information.
  </blockquote>

  <h3>Basic Structure and Types</h3>
  <p>The SR latch can be implemented using either:</p>
  <ol>
    <li>
      <strong>Two cross-coupled NOR gates</strong>: In this configuration, both
      inputs are normally \(0\), and applying a \(1\) to either input changes
      the state.
    </li>
    <li>
      <strong>Two cross-coupled NAND gates</strong>: Here, both inputs are
      normally \(1\), and applying a \(0\) to either input changes the state.
    </li>
  </ol>
  <p>
    In both implementations, the circuit has two outputs, \(Q\) and \(Q'\),
    which are normally complementary to each other.
  </p>
  <div class="res-contaner">
    <center>
      <img src="1.png" />
      <caption>
        123 NOR Based SR Latch
      </caption>
    </center>
  </div>
  <div class="res-contaner">
    <center>
      <img src="2.png" />
      <caption>
        123 NAND Based SR Latch
      </caption>
    </center>
  </div>

  <h3>Operation of NOR-Based SR Latch</h3>
  <p>The NOR-based SR latch operates as follows:</p>
  <ul>
    <li>
      <strong>Set State</strong>: When \(Q=1\) and \(Q'=0\), the latch is in the
      set state
    </li>
    <li>
      <strong>Reset State</strong>: When \(Q=0\) and \(Q'=1\), the latch is in
      the reset state
    </li>
  </ul>
  <p>
    Under normal operation, both inputs remain at \(0\) unless a state change is
    desired. The latch's behavior follows this truth table:
  </p>

  <table>
    <thead>
      <tr>
        <th>S</th>
        <th>R</th>
        <th>Q</th>
        <th>Q'</th>
        <th>State Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>Last \(Q\)</td>
        <td>Last \(Q'\)</td>
        <td>Memory state (holds previous value)</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>\(0\)</td>
        <td>\(1\)</td>
        <td>Reset state</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>\(1\)</td>
        <td>\(0\)</td>
        <td>Set state</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>\(0\)</td>
        <td>\(0\)</td>
        <td>Forbidden state</td>
      </tr>
    </tbody>
  </table>

  <h3>The Forbidden State</h3>
  <p>
    The input combination \(S=R=1\) in a NOR-based latch causes both outputs to
    go to \(0\), violating the requirement that outputs be complementary. This
    is called the "forbidden state" or "invalid state".
  </p>
  <p>
    When both inputs subsequently return to \(0\) from this forbidden state, the
    next state is unpredictable and depends on which input returns to \(0\)
    first. This can lead to:
  </p>
  <ul>
    <li>Race conditions</li>
    <li>Metastable states</li>
    <li>Unpredictable outputs</li>
  </ul>
  <p>This condition should be avoided in practical applications.</p>

  <h3>NAND-Based SR Latch</h3>
  <p>
    The NAND-based SR latch operates with inverted input logic compared to the
    NOR version:
  </p>
  <ul>
    <li>Normally both inputs are kept at \(1\)</li>
    <li>\(S=0, R=1\) puts the latch in the set state (\(Q=1, Q'=0\))</li>
    <li>\(S=1, R=0\) puts the latch in the reset state (\(Q=0, Q'=1\))</li>
    <li>\(S=R=0\) is the forbidden state</li>
  </ul>
  <p>
    This implementation is sometimes referred to as an \(S'R'\) latch to
    indicate that the inputs are active-low.
  </p>
  <div class="res-contaner">
    <center>
      <img src="3.png" />
      <caption>
        SR Latch with Enable
      </caption>
    </center>
  </div>
  <h3>SR Latch with Control Input</h3>
  <p>
    The basic SR latch can be modified by adding a control input (also called
    Enable or En) that determines when the state of the latch can be changed.
    This creates a gated SR latch which:
  </p>
  <ul>
    <li>
      Uses an additional input to enable/disable the \(S\) and \(R\) inputs
    </li>
    <li>
      Prevents the latch from changing state when the enable input is inactive
    </li>
    <li>Allows state changes only when the enable signal is active</li>
  </ul>
  <p>In the NAND implementation with enable:</p>
  <ul>
    <li>
      When \(En=0\), the state of the latch cannot change regardless of \(S\)
      and \(R\) values
    </li>
    <li>
      When \(En=1\), the \(S\) and \(R\) inputs can affect the latch state
    </li>
    <li>When \(En=1, S=1, R=0\), the latch enters the set state</li>
    <li>When \(En=1, S=0, R=1\), the latch enters the reset state</li>
  </ul>
  <p>
    If \(En=1\) and both \(S\) and \(R\) are \(1\) (for NAND implementation),
    the circuit enters an indeterminate state, which should be avoided.
  </p>

  <div class="res-code">
    <pre><code class="language-verilog">
module sr_latch(
  input wire S, R,
  output wire Q, Q_not
);
  assign Q = ~(R | Q_not);
  assign Q_not = ~(S | Q);
endmodule</code></pre>
  </div>

  <h2>D Latch</h2>
</div>
