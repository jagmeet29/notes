<script src="../comm.js"></script>
<link rel="stylesheet" href="../css.css" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<div id="container">
  <h1>$1$-Bit Storage Element</h1>
  <h2>SR Latch</h2>
  <blockquote>
    The SR latch (Set-Reset latch) is a fundamental digital storage element that
    serves as the building block for more complex sequential circuits. It
    consists of two cross-coupled logic gates that create a feedback loop,
    allowing the circuit to store one bit of information.
  </blockquote>

  <h3>Basic Structure and Types</h3>
  <p>The SR latch can be implemented using either:</p>
  <ol>
    <li>
      <strong>Two cross-coupled NOR gates</strong>: In this configuration, both
      inputs are normally \(0\), and applying a \(1\) to either input changes
      the state.
    </li>
    <li>
      <strong>Two cross-coupled NAND gates</strong>: Here, both inputs are
      normally \(1\), and applying a \(0\) to either input changes the state.
    </li>
  </ol>
  <p>
    In both implementations, the circuit has two outputs, \(Q\) and \(Q'\),
    which are normally complementary to each other.
  </p>
  <div class="res-container">
    <center>
      <img src="1.png" />
      <caption>
        123 NOR Based SR Latch
      </caption>
    </center>
  </div>
  <div class="res-container">
    <center>
      <img src="2.png" />
      <caption>
        123 NAND Based SR Latch
      </caption>
    </center>
  </div>

  <h3>Operation of NOR-Based SR Latch</h3>
  <p>The NOR-based SR latch operates as follows:</p>
  <ul>
    <li>
      <strong>Set State</strong>: When \(Q=1\) and \(Q'=0\), the latch is in the
      set state
    </li>
    <li>
      <strong>Reset State</strong>: When \(Q=0\) and \(Q'=1\), the latch is in
      the reset state
    </li>
  </ul>
  <p>
    Under normal operation, both inputs remain at \(0\) unless a state change is
    desired. The latch's behavior follows this truth table:
  </p>

  <table>
    <thead>
      <tr>
        <th>S</th>
        <th>R</th>
        <th>Q</th>
        <th>Q'</th>
        <th>State Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>Last \(Q\)</td>
        <td>Last \(Q'\)</td>
        <td>Memory state (holds previous value)</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>\(0\)</td>
        <td>\(1\)</td>
        <td>Reset state</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>\(1\)</td>
        <td>\(0\)</td>
        <td>Set state</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>\(0\)</td>
        <td>\(0\)</td>
        <td>Forbidden state</td>
      </tr>
    </tbody>
  </table>

  <h3>The Forbidden State</h3>
  <p>
    The input combination \(S=R=1\) in a NOR-based latch causes both outputs to
    go to \(0\), violating the requirement that outputs be complementary. This
    is called the "forbidden state" or "invalid state".
  </p>
  <p>
    When both inputs subsequently return to \(0\) from this forbidden state, the
    next state is unpredictable and depends on which input returns to \(0\)
    first. This can lead to:
  </p>
  <ul>
    <li>Race conditions</li>
    <li>Metastable states</li>
    <li>Unpredictable outputs</li>
  </ul>
  <p>This condition should be avoided in practical applications.</p>

  <h3>NAND-Based SR Latch</h3>
  <p>
    The NAND-based SR latch operates with inverted input logic compared to the
    NOR version:
  </p>
  <ul>
    <li>Normally both inputs are kept at \(1\)</li>
    <li>\(S=0, R=1\) puts the latch in the set state (\(Q=1, Q'=0\))</li>
    <li>\(S=1, R=0\) puts the latch in the reset state (\(Q=0, Q'=1\))</li>
    <li>\(S=R=0\) is the forbidden state</li>
  </ul>
  <p>
    This implementation is sometimes referred to as an \(S'R'\) latch to
    indicate that the inputs are active-low.
  </p>
  <div class="res-container">
    <center>
      <img src="3.png" />
      <caption>
        SR Latch with Enable
      </caption>
    </center>
  </div>
  <h3>SR Latch with Control Input</h3>
  <p>
    The basic SR latch can be modified by adding a control input (also called
    Enable or En) that determines when the state of the latch can be changed.
    This creates a gated SR latch which:
  </p>
  <ul>
    <li>
      Uses an additional input to enable/disable the \(S\) and \(R\) inputs
    </li>
    <li>
      Prevents the latch from changing state when the enable input is inactive
    </li>
    <li>Allows state changes only when the enable signal is active</li>
  </ul>
  <p>In the NAND implementation with enable:</p>
  <ul>
    <li>
      When \(En=0\), the state of the latch cannot change regardless of \(S\)
      and \(R\) values
    </li>
    <li>
      When \(En=1\), the \(S\) and \(R\) inputs can affect the latch state
    </li>
    <li>When \(En=1, S=1, R=0\), the latch enters the set state</li>
    <li>When \(En=1, S=0, R=1\), the latch enters the reset state</li>
  </ul>
  <p>
    If \(En=1\) and both \(S\) and \(R\) are \(1\) (for NAND implementation),
    the circuit enters an indeterminate state, which should be avoided.
  </p>
  <hr />
  <h2>SR Latch</h2>
  <pre><code class="language-verilog">
    module sr_latch (
      input wire enable,   // Enable input
      input wire reset,    // Active high reset
      input wire s,        // Set input
      input wire r,        // Reset input
      output reg q         // Output
  );
      
      // Trigger on changes to enable, s, r, or reset
      always @(enable or s or r or reset) begin
          if (reset)
              q <= 1'b0;           // Reset output to 0
          else if (enable) begin
              case ({s, r})
                  2'b00: q <= q;      // No change
                  2'b01: q <= 1'b0;   // Reset
                  2'b10: q <= 1'b1;   // Set
                  2'b11: q <= 1'bx;   // Invalid state
              endcase
          end
          // else hold state (implicit)
      end
      
  endmodule  
</code></pre>
  <h2>D Latch</h2>
  <pre><code class="language-verilog">
    module d_latch (
      input wire enable,   // Enable input
      input wire reset,    // Active high reset
      input wire d,        // Data input
      output reg q         // Output
  );
      
      // Trigger on changes to enable, d, or reset
      always @(enable or d or reset) begin
          if (reset)
              q <= 1'b0;           // Reset output to 0
          else if (enable)
              q <= d;              // Capture D when enabled
          // else hold state (implicit)
      end
      
  endmodule   
  </code></pre>
  <h2>Enabled D Latch</h2>
  <pre><code class="language-verilog">
    module enabled_d_latch (
      input wire clk,      // Clock input (acts as enable)
      input wire reset,    // Active high reset
      input wire en,       // Enable signal
      input wire d,        // Data input
      output reg q         // Output
  );
      
      // Trigger on changes to clock, en, d, or reset
      always @(clk or en or d or reset) begin
          if (reset)
              q <= 1'b0;           // Reset output to 0
          else if (clk && en)      // Only capture when both clock and enable are high
              q <= d;
          // else hold state (implicit)
      end
      
  endmodule  
  </code></pre>
  <h2>Master Slave JK Flip Flop</h2>
  <pre><code class="language-verilog">
    module master_slave_jk_flip_flop (
      input wire clk,      // Clock input
      input wire reset,    // Active high reset
      input wire j,        // J input
      input wire k,        // K input
      output reg q         // Output
  );
      
      reg master_q;        // Master stage output
      
      // Master stage: captures on positive edge
      always @(posedge clk or posedge reset) begin
          if (reset)
              master_q <= 1'b0;
          else begin
              case ({j, k})
                  2'b00: master_q <= master_q;  // No change
                  2'b01: master_q <= 1'b0;      // Reset
                  2'b10: master_q <= 1'b1;      // Set
                  2'b11: master_q <= ~master_q; // Toggle
              endcase
          end
      end
      
      // Slave stage: captures on negative edge
      always @(negedge clk or posedge reset) begin
          if (reset)
              q <= 1'b0;
          else
              q <= master_q;       // Transfer from master to slave
      end
      
  endmodule  
  </code></pre>
  <h2>SR Flip Flop</h2>
  <pre><code class="language-verilog">
    module sr_flip_flop (
      input wire clk,      // Clock input
      input wire reset,    // Active high reset
      input wire s,        // Set input
      input wire r,        // Reset input
      output reg q         // Output
  );
      
      always @(posedge clk or posedge reset) begin
          if (reset)
              q <= 1'b0;   // Reset output to 0
          else begin
              case ({s, r})
                  2'b00: q <= q;      // No change
                  2'b01: q <= 1'b0;   // Reset
                  2'b10: q <= 1'b1;   // Set
                  2'b11: q <= 1'bx;   // Invalid state
              endcase
          end
      end
      
  endmodule  
  </code></pre>
  <h2>JK Flip Flop</h2>
  <pre><code class="language-verilog">
    module jk_flip_flop (
      input wire clk,      // Clock input
      input wire reset,    // Active high reset
      input wire j,        // J input (set)
      input wire k,        // K input (reset)
      output reg q         // Output
  );
      
      always @(posedge clk or posedge reset) begin
          if (reset)
              q <= 1'b0;   // Reset output to 0
          else begin
              case ({j, k})
                  2'b00: q <= q;      // No change
                  2'b01: q <= 1'b0;   // Reset
                  2'b10: q <= 1'b1;   // Set
                  2'b11: q <= ~q;     // Toggle
              endcase
          end
      end
      
  endmodule  
  </code></pre>
  <h2>T Flip Flop</h2>
  <pre>
    <code class="language-verilog">
      module t_flip_flop (
        input wire clk,      // Clock input
        input wire reset,    // Active high reset
        input wire t,        // Toggle input
        output reg q         // Output
    );
        
        always @(posedge clk or posedge reset) begin
            if (reset)
                q <= 1'b0;   // Reset output to 0
            else if (t)
                q <= ~q;     // Toggle output if t=1
            // else maintain state (implicit)
        end
        
    endmodule    
    </code>
  </pre>
  <h2>D Flip Flop</h2>
  <pre><code class="language-verilog">
    module d_ff_pos (
      input d,      // Data input
      input clk,    // Clock input
      input reset,  // Reset input
      output reg q  // Output
  );
      
      // Behavioral description using always block
      always @(posedge clk or posedge reset) begin
          if (reset)
              q <= 1'b0;  // Asynchronous reset
          else
              q <= d;     // Store D input on positive clock edge
      end
      
  endmodule  
  </code></pre>
</div>
