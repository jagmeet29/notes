<script src="../comm.js"></script>
<link rel="stylesheet" href="../css.css" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<div id="container">
    <h1>Process-To-Process Delivery</h1>
    <div class="res-container">
        <img src="1.png" width="600px" />
        </div>
        <div class="res-container">
        <table>
            <tr>
            <th>Layer</th>
            <th>Address Used</th>
            <th>Purpose</th>
            </tr>
            <tr>
            <td>Data-Link</th>
            <td>MAC Address</th>
            <td>Identifies a node on a local network</th>
            </tr>
            <tr>
            <td>Network</th>
            <td>IP Address</th>
            <td>Identifies a host on the global Internet</th>
            </tr>
            <tr>
            <td>Transport</th>
            <td>Port Number</th>
            <td>Identifies a process/application on a host</th>
            </tr>
            <tr>
            <td>Application</th>
            <td>Application Name</th>
            <td>User-friendly identifier (e.g., URL, email)</th>
            </tr>
            </table></div>
            
            
        <h2>Types of Delivery</h2>
        <h3>Node to Node Delivery</h3>
        <blockquote>Delivery of frames between two neighboring nodes over a link by data-link layer.
        </blockquote>
<h3>Host to Host Delivery</h3>
<blockquote>
Delivery of data-grams between two hosts by  network layer.
</blockquote>



But communication on Internet is not defined as the exchanged of data between two nodes or between two hosts…
Real communication takes place between two processes (application programs).<br><br>
But at a single time many processes are running at source and destination.<br><br>
A mechanism is required to deliver data from one of these processes running on the source host to the corresponding process running on the destination host.

<h3>Process to Process Delivery</h3>
<blockquote> transport layer is responsible for process-to-process delivery.</blockquote>
<h3>Client Server Paradigm</h3>

<blockquote>The client-server paradigm is a common model used in computer networks and distributed applications where two types of processes communicate: a client and a server.</blockquote>
<p>
<b>Client:</b> A process (program) running on a local computer that requests a service or resource.
<br><br>
<b>Server:</b> A process running on a remote (or sometimes the same) computer that provides the requested service or resource.

<p class="note"> Note that both the process have the same name.</p>

<b>Request-Response Pattern:</b> The client initiates communication by sending a request to the server. The server waits for such requests and responds by providing the requested service or data. This interaction follows a request-response pattern.
<br><br>
<b>How It Works:</b> The client process sends a request to the server process, typically over a network. The server process receives the request, processes it, and sends back a response. The client receives the response and uses the data or service accordingly.
<br><br>
<b>Example:</b> For example, when you use a web browser (client) to access a website, your browser sends a request to the web server. The server processes this request and sends back the webpage to your browser.
   
<h4 >
    For communication we must define the following:
</h4>
<ul>
<li>Local host.</li>
<li>Local process.</li> 
<li>Remote host.</li>
<li>Remote process.</li>
</ul>

Operating systems today support both multi-user and multi-programming environments. A server and client both can run several programs at the same time.
</p>

<div class="res-container">
        <img src="4.png" width="400px" />
        </div>
<h2>Addressing</h2>
<blockquote>Addressing in computer networks, especially at the transport layer, is the method used to deliver data from one specific process on a host to another specific process on a different host.</blockquote>

<b>
It involves two key identifiers at each end of the communication:</b>
<ol>

<li>IP Address</li>
<li>Port Number</li>
</ol>
 
<b>IP Address</b>
<blockquote>Identifies the host (computer or device) uniquely on the network.</blockquote>
<p>Used by the network layer to deliver packets from one host to another.<br><br>
<b>Example:</b>
 192.168.1.1
</p>
<p>
<b>Port Number</b>
<blockquote>Identifies the specific process (application or service) running on the host.</blockquote>
<p>Used by the transport layer to distinguish among multiple processes running on the same host.<br><br>
<b>Example:</b> 80 (for HTTP), 443 (for HTTPS), 25 (for SMTP)</p>
<p>In the Internet model, the port numbers are 16-bit integers between 0 and 65,535.
</p>
<p>Port numbers allow multiplexing and demultiplexing of data to/from applications.</p>
</p>
<div class="res-container">
        <img src="3.png" width="400px" />
        </div>
<h3>
   IP Address + Port Number =  Socket Address
</h3>
<blockquote>To uniquely identify a process on a host, we combine the IP address and port number. This combination is known as a socket address.</blockquote>
<p>The IP header contains the IP address, the UDP or TCP header contains the port numbers</p>
<b>Example:</b> 192.168.1.1:80 (IP address + port 80, typically for HTTP server).
<br><br>
Both client and server have socket addresses to uniquely identify the communicating processes.
<br><br>
<h4>Port Number Categories</h4>
<div class="res-container">
  <div class="res-container">
    <img src="8.png">
  </div>
<table>
<tr>    
<th>Port Number Range</th>
<th>Category</th>
<th>Description</th>
</tr>
<tr>
<td>0–1023</td>
<td>Well-known</td>
<td>Assigned and controlled by IANA for common services (e.g., HTTP: 80, FTP: 21)</td>
</tr>
<tr>
<td>1024–49151</td>
<td>Registered</td>
<td>Registered with IANA for specific services/applications</td>
</tr>
<tr>
<td>49152–65535</td>
<td>Dynamic/Ephemeral</td>
<td>Used temporarily by client processes, not registered</td>
</tr>
</table></div>
<br>
<div class="res-container">
  <img src="9.png">
</div>
<p>These categories help manage port assignments and avoid conflicts between different applications and services. <br>
<br>

The server process must also define itself with a port number, this port number is however cannot be chosen randomly.
If the computer at the server site runs a server process and assigns a random port number.<br><br>
The process at the client that wants to access that server and use its services will NOT know the port number.
One solution is that the host send a special packet and request the port number, but this requires more overhead.
<br><br>Servers use well-known ports so clients know where to send requests (e.g., web servers use port 80).<br><br>

Clients typically use dynamic or ephemeral ports, which are assigned temporarily for the duration of a connection</p>  
<p><b>Example: </b>A Daytime client process, can use an ephemeral (temporary) port number 52,000 to identify itself.
    The Daytime server process must use the well-known (permanent) port number 13.
    </p>
<div class="res-container">
        <img src="2.png"  width="500px"/><br><br>
        </div>

        
        <h2>Connectionless vs Connection-Oriented Service</h2>
        <div class="res-container">
        <table>
          <tr>
            <th>Feature</th>
            <th>Connectionless Service</th>
            <th>Connection-Oriented Service</th>
          </tr>
          <tr>
            <td>Connection Setup</td>
            <td>No setup required before data transfer</td>
            <td>Requires connection establishment before transfer</td>
          </tr>
          <tr>
            <td>Analogy</td>
            <td>Like sending a letter via postal system</td>
            <td>Like making a phone call</td>
          </tr>
          <tr>
            <td>Data Path</td>
            <td>Each packet may take a different route</td>
            <td>All data follows the same virtual path</td>
          </tr>
          <tr>
            <td>Order of Delivery</td>
            <td>Packets may arrive out of order</td>
            <td>Data arrives in the same order as sent</td>
          </tr>
          <tr>
            <td>Reliability</td>
            <td>No guarantee of delivery or order</td>
            <td>Reliable delivery and order guaranteed</td>
          </tr>
          <tr>
            <td>Acknowledgment</td>
            <td>No acknowledgment of receipt</td>
            <td>Uses acknowledgments for error and flow control</td>
          </tr>
          <tr>
            <td>Congestion Control</td>
            <td>Prone to congestion</td>
            <td>Less prone due to controlled connection</td>
          </tr>
          <tr>
            <td>Overhead</td>
            <td>Low protocol overhead</td>
            <td>Higher overhead due to connection management</td>
          </tr>
          <tr>
            <td>Typical Protocol</td>
            <td>UDP (User Datagram Protocol)</td>
            <td>TCP (Transmission Control Protocol)</td>
          </tr>
          <tr>
            <td>Use Case</td>
            <td>Suitable for real-time, bursty, or simple requests (e.g., streaming, DNS)</td>
            <td>Suitable for long, steady communication (e.g., file transfer, web browsing)</td>
          </tr>
          <tr>
            <td>Examples</td>
            <td>DNS, VoIP, TFTP, SNMP</td>
            <td>HTTP, FTP, SMTP, Telnet</td>
          </tr>
        </table></div>

<h3>Connection Establishment
</h3>

<div class="res-container">
  <img src="5.png">
</div><h4>Steps:</h4>
<ol>
  
  <li>Host A sends a packet to announce wish for connection establishment and includes its initial information about traffic from A to B.</li><li>
  Host B sends a packet to acknowledge (confirm) the request of A.</li><li>
  Host B sends a packet that includes its initialization information about traffic from B to A.</li><li>
  Host A sends a packet to acknowledge (confirm) the request of B.</li>
  
</ol>

<p>
It is a 4 step process but can also be 3 step.
    As step 2 and 3 can be combined into one.(Host B confirms the request form Host A and sends its own request)

  </p>
  <h4>Sequence Number and Acknowledgment Number</h4>
  <ul>
  <li>Each connection request needs to have a sequence number to recover from the loss or duplication of the packet.
  </li><li>Each acknowledgement needs to have an acknowledgement number as well, for the same reason.
    </li>
    <li>The first sequence number in each direction must be a random for each connection establishment.
    </li>
    <li>A sender cannot create several connections that start with the same sequence (e.g. 1)
      The reason is to prevent a situation called <em>playback</em>.
      </li>

<p><b>Example</b> In bank transaction a customer makes a connection and requests a transfer of $1 million to a third party.
  If the network somehow duplicates the transaction after the first connection is closed, the bank may assume that there is a new connection and transfer another <e>$</e>1 million to third party.</p><p>
  This would probably not happen if the protocol required that the sender use a different sequence number each time it made a new connection.
  The bank would recognize a repeated sequence number and know that the request was a duplicate.
  </p>
  <li>Using a sequence number for each connection requires that the receiver keep a history of sequence numbers for each remote host for a specific time.
  </li>
  </ul> 
  <h3>Connection Termination</h3>
  <div class="res-container">
    <img src="7.png">
  </div>
  <ul>
    <li>Any of the two parties involved in exchanging data can close the connection.</li><li>      When connection in one direction is terminated, the other party can continue sending data in the other direction.</li><li>
      So 4-actions are needed to close the connection in both directions.
      </li>
      <li>It can't be converted into 3 step process as both parties may not wish to terminate the communication at the same time.</li>
  </ul>
  <h4>Steps:</h4>
  <ol>
    <li>
Host A sends a packet announcing its wish for connection termination.</li><li>
Host B sends segment acknowledgement (confirming) the request of A.</li>
After this connection is closed in one direction, but not in the other.</li><li>
Host B can continue sending data to host A.</li><li>
When host B finishes sending its own data, it sends a segment indicate that it wants to close the connection.</li><li>
Host A acknowledges (confirms) the request of B.</li>

  </ol>
  <h2>Reliable vs Unreliable</h2>
  <div class="res-ques">
    <h4> How can we make a connection-oriented transport layer over a connectionless network-layer protocol such as IP?</h4>
    <button class="ans-button">Show Answer</button>
    <div class="ans-content">
      <ul>
     <li> According to the design goal of Internet, the two layers are totally independent.</li><li>
      The transport layer only uses the services of the network layer.</li>
      
      <b>Example</b> <ul>
        <li>The post office service is connectionless.</li>
        <li>
      Each parcel delivered to post office is independent from the next even if we deliver 100 parcels to the same destination.
    </li>
      <li>      The post office cannot guarantees that the parcels arrive at the same destination in order even if the parcels are numbered.

      </li>
      <li>
      But we can create a connection-oriented service on the top of this service.</li><li>
      We can have an agent at the destination city and send the numbered parcels to her.</li><li>
      The agent can keep the parcels until all of them arrived.</li><li>
      Then put them in order and delivered them to the destination.
      If a parcel is lost the agent can ask for a duplicate.
      We can create a connection to the post office and get her confirmation.</li><li>
      After all parcels have been received, we can call again to announce the disconnection of the service.</li></ul>
  </div></div>

<p>
The transport layer services can be reliable or unreliable.</p> <p>
If the application-layer program needs the reliability, we use a reliable transport-layer protocol by implementing flow and error control at the transport-layer. (e.g. TCP) 
Means a slower and complex service.<br>
If the application program does NOT need reliability, (because it uses its own flow and error control (real-time applications)), then an unreliable protocol can be used. (e.g. UDP)
</p>
<div class="res-ques">
  <h4>IF the data-link layer is reliable and has flow control and error control, do we need this at the transport layer too?
  </h4>
  <button class="ans-button">
    Show Answer
  </button>
  <div class="ans-content">
    The answer is YES…<br>
Reliability at the data-link layer is between the two nodes, we need the reliability between the two ends.
Because the network layer in the Internet is unreliable (best-effort-delivery). We need to implement reliability at the transport layer.

  </div>
</div><p>The image below shows that error-control at the data-link layer does not guarantee error control at the transport layer.
</p>
<div class="res-container">
  <img src="6.png">
</div>
